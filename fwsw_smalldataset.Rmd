---
title: "FWSW with smallest dataset"
output: html_document
author: "Sarah P. Flanagan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
description: "Re-running the freshwater-saltwater analysis using only the dataset from pairwise population comparisons"
---

In my initial analysis of the freshwater-saltwater dataset, I had three vcf files: 
1. one generated from all pairwise comparisons of populations, containing SNPs only found in all 16 populations, in 75% of individuals, and with a minor allele frequency of at least 5%. ("separate")
2. one generated from all pairwise comparisons of populations, containing SNPs found in 4 populations, in 75% of individuals, and with a minor allele frequency of at least 5%. ("P4")
3. one generated from comparing lumped 'freshwater' and 'saltwater' populations, containing SNPs found in 50% of individuals and with a minor allele frequency of at least 5%. ("lumped")

I did the majority of the analyses using set #3, but would like to explore what changes if I use dataset #2. I think #1 is too restrictive. Dataset #2 is in the "subset" dataset, and is what I ran the structure analyses on. This is the dataset I'm going to move forward with for the paper.

Note that in most of these cases the actual analysis will be set to `eval=FALSE` once I've run it once, because then I save the output and only have to read it in, saving compilation time.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir='./fwsw_results/')
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../scripts/treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
```

```{r access_analysis, echo=FALSE}
knitr::read_chunk("../scripts/fwsw_analysis.R")
```

```{r FWSWsetup, include=FALSE}
```

```{r pwiseFstsFiles,eval=FALSE}
```

```{r P4plink,cache=TRUE}
```

This P4/subset dataset has `r nrow(map.sub)` SNPs from `r length(unique(gsub("(\\d+)_\\d+","\\1",map.sub$V2)))` RAD loci, from `r nrow(ped.sub)` indivudals in 16 populations.

## Generate a new vcf file

The first thing to do is to create a vcf file using the subset parameters. I've already got a whitelist of loci in the subsetted dataset, so I need to run `populations -b 2 -W fwsw_results/subset.whitelist.txt -P fwsw_results/stacks -M fwsw_pops_map.txt --vcf`, which I did on 2017-12-18 on silivren-lond. I then re-named it to p4.vcf (and the other output files).


```{r read_vcf,cache=TRUE}
vcf<-parse.vcf("stacks/p4.vcf") #this is the smaller dataset
```
```{r vcfSetup, echo=TRUE}
```

The vcf file contains `r nrow(vcf)` SNPs from `r length(unique(vcf$ID))` RAD loci.

Choose a subset of the SNPs to re-use. [Do I need to do this?]

```{r choose_subset, eval=FALSE} 
chosen.snps<-choose.one.snp(vcf)$SNP
write.table(chosen.snps,"chosen.all.snps.txt",quote=F)
```

```{r read_subset}
chosen.snps<-unlist(read.table("chosen.all.snps.txt"))
```

There are `r length(chosen.snps)` SNPs that I'll use from the vcf file, from `r nrow(vcf)` RAD loci.

## Figure 1

The first figure in the paper is a map of the collection sites.

```{r map, eval=FALSE}
```
![Figure 1. Map of collection sites](fwsw_results/all_sites_map.jpg)

## Figure 2

The second figure in the paper is showing population structure, using STRUCTURE, adegenet, and PCAdapt. These analyses were run as exactly written in `fwsw_analysis.R`, so I won't reproduce that code here.

```{r Adegenet, eval=FALSE, echo=FALSE}
```
```{r pcadapt, eval=FALSE, echo=FALSE}
```
```{r readStructure, eval=FALSE, echo=FALSE}
```
```{r AnalyzeStructure, eval=FALSE, echo=FALSE}
```
```{r PopStructurePlot, eval=FALSE, echo=FALSE}
```

![Figure 2. Population Structure](fwsw_results/pop_structure_comb.jpeg)


## Figure 3

I don't need to re-calculate pairwise Jost's D, and Fsts using the P4 (or "subset") dataset, so I can just read in those files. 

```{r read_existing_files}
jostpw<-read.delim("Subset.JostsD.tsv",sep='\t',header=TRUE,row.names=1)
```


### Treemix

To run treemix, I follow the following steps:

1. Fit tree without migration
2. Add migration edges using `-m`.
3. Use f3 and f4 ancestry estimation to approximate the amount of admixture and compare to treemix.
4. Use f4 statistics to understand poor fits.

All of these require setting a root, which is FLPB based on previous trees.

First, I need to create a file in the correct format, which uses the vcf file: 

```{r nameTreemix}
treemix.name<-"treemix/p4_treemix"
treemix.prefix<-"treemix/p4_"
poporder.file<-"treemix/poporder"
fst.tree.name<-as.character("ALLfst_cov_heatmap.png")
```
```{r generateTreemix, eval=FALSE}
```

Then, in unix, I need to run `gzip -c treemix/p4_treemix > treemix/p4_treemix.gz`. Now I can run `scripts/run_treemix.sh`, which implements steps 1 and 2, and which I need to run in Ubuntu. *Note that there are a lot of "no counts" warnings from treemix. Also, that it runs very quickly*

After that, I can evaluate the different outcomes.

```{r TreemixSetup}
```
```{r FLPBoutgroup, results="hide",fig.keep="high"}
```

Population pairs that are 'too far apart' on the tree (have high error estimates) are ones that are likely candidates for gene flow - and these are the squares with dark greens, blues, and black. These are LAFW-TXFW and ALFW-TXFW in almost all of the SE graphs

```{r FLPBmigration, results="hide",fig.keep="high"}
```

Look at the p-values: do migration events always improve the fit of the data?

```{r FLPBpvals}
```

All of the added migration edges improve the fit. Evaluating both the residual and migration edge plots, we can see that four migration edges reduces the error between LAFW & TXFW and ALFW & TXFW. The largest SE is between FLFW (FLLG) and itself, and secondarily between LAFW and itself. This means that those branches are surprisingly long, which I am comfortable accepting. The strongest migration edge, between the branch from the Atlantic Florida to Gulf Florida populations -> FLAB, is unsurprising because that is an intermediate location between the Atlantic and Gulf coasts. In some of the structure analyses it clusters with the Gulf coast and in others it is its own admixed group - supporting the tree structure here.

The other migration events are somewhat more surprising. We will evaluate those using the three and four population analyses.

#### Evaluating migration edges

First, let's read in the three and four population analysis results. These tested all possible three- and four-population tree groups to see whether they pass a test of 'treeness'. If not, their p-value will be small, and they don't form a nice tree.

```{r f3f4}
f3.name<-"treemix/p4_threepop.txt"
f4.name<-"treemix/p4_fourpop.txt"

#extract the relevant lines
extract.fs<-function(filename,pat="^[A-Z]{4};"){
  f<-readLines(filename)
  fmatch<-f[grep(pat,f)]
  f<-read.table(text=fmatch)
  colnames(f)<-c("pops","f","SE","Z")
  return(f)
}
f3<-extract.fs(f3.name)
f4<-extract.fs(f4.name,pat="^[A-Z]{4},")

#add p-values
f3$p<-pnorm(f3$Z)
f4$p<-pnorm(f4$Z)

```

Now we can investigate the migration edges added to the trees. 

##### Atlantic/Gulf->FLAB

This least surprising migration edge would be expected to show a signature of admixture. I'll check the treeness of FLHB;FLSI,FLAB and FLHB,FLCC;FLSI,FLAB. For comparison, I can look at FLHB;FLSI,FLFD and FLHB,FLCC;FLSI,FLFD

```{r FL}
checks3<-c("FLHB;FLSI,FLAB","FLHB;FLFD,FLSI")
f3[f3$pops %in% checks3,]
checks4<-c("FLSI,FLAB;FLHB,FLCC","FLFD,FLSI;FLHB,FLCC")
f4[f4$pops %in% checks4,]
```
They pass the three-population tests but not the four-population tests. 

##### TXFW->TXCB

To investigate this migration edge, I need to evaluate whether a [TXFW[TXCB,TXCC]] or [TXFW[TXCB,TXSP]] topology is an appropriate tree. 

```{r TX_f3}
checks<-c("TXFW;TXCC,TXCB",
          "TXFW;TXSP,TXCB")
f3[f3$pops %in% checks,]
```

Neither of these fail the treeness test, so TXFW is essentially functioning as an effective outgroup/more ancestral population. Let's check if a four population tree also makes sense.

```{r TX_f4}
f4[f4$pops %in% "TXSP,TXCC;TXFW,TXCB",]
```

This also passes the treeness test - so this isn't an actual admixture event, more of demonstrating shared ancestry.

##### TXFW->LAFW/ALFW

This migration edge would suggest a three-population structure of [TXFW[ALFW,LAFW]] or a four-population structure of [TXFW,TXCB[LAFW,ALFW]] or [TXFW,ALST[LAFW,ALFW]]
```{r TXFW_ALLAFW}

checks<-c("TXFW,TXCB;LAFW,ALFW",
          "TXFW,ALST;LAFW,ALFW")#to get the correct order of populations I had to
                                #use grep and manually try a few different ones
f4[f4$pops %in% checks,]
f3[f3$pops == "TXFW;LAFW,ALFW",]

```

The three-population test does not fail the treeness test but the four-population tests do fail the treeness tests. This suggests that TXFW functions as an outgroup to the LAFW and ALFW - they are perhaps derived from the TXFW population rather than experiencing current admixture.

##### FLFW->TX/AL

FLLG is actually FLFW, and there's a migration edge from it to the Alabama/Louisiana clade and the Texas clade. So, we can test FLLG;ALST,TXFW, FLLG;ALFW,TXCB, FLLG;ALFW,TXFW or FLLG;ALST,TXCC - see if the migration is specifically to freshwater populations or not.

```{r FLFW_f3}
checks<-c("FLLG;TXFW,ALST","FLLG;TXCB,ALFW","FLLG;TXCB,LAFW",#mix of freshwater
          "FLLG;TXFW,ALFW","FLLG;TXFW,LAFW",                 #all freshwater
          "FLLG;TXCC,ALST")                                  #no freshwater
f3[f3$pops %in% checks,]
```
These all pass the treeness test.

#### Plot the chosen tree

```{r treemix_define}
treemix.file<-as.character("treemix/p4_k100bFLPBr.cov.gz")
tm.vertices<-"treemix/p4_k100bFLPBrm4.vertices.gz"
tm.plot<-"treemix/p4_treemix_m4_FLPB.png"
tm.tree<-"treemix/p4_k100bFLPBrm4"
```
```{r TreemixFavorite, echo=FALSE,results="hide",fig.keep="high"}
```

### PopTree2

For the PopTree2 analysis, I need to convert the vcf file to genepop format. I did this using PGDSpider2. Then I ran PopTree2 on Windows10, using Da to calculate neighbor-joining trees and using 1000 bootstrap replicates.

Or, if that doesn't work,

```{r CreatePoptreeSubsets, eval=FALSE}
```

And then run poptree

```{r poptree_prefix, eval=FALSE}
poptree.prefix<-"poptree/p4."
poptree.png<-"p4.poptree.png"
```
```{r AnalyzePoptree, eval=FALSE}
```
```{r PlotFullPoptreeSubset, eval=FALSE}
```


## Figure 4

Figure 4 is the Poptree2 and Treemix trees next to each other

```{r tree_files,eval=FALSE}
plotName<-"p4.trees.png"
tm.tree<-"treemix/p4_k100bFLPBrm4"
#pt.subtree<-
```
```{r plotTreemixPoptree,eval=FALSE}
```
```{r, eval=FALSE}
#![Figure 4. Trees](fwsw_results/p4.trees.png)
```

## Figure 5

I need to re-run `populations` because I don't seem to have the correct fst files. I can use the whitelist and hopefully include bootstrapping and kernel smoothing: 

`populations -b 2 -W fwsw_results/subset.whitelist.txt -P fwsw_results/stacks -M fwsw_pops_map.txt --fstats --vcf_haplotypes --genomic --bootstrap -k `

And then I will identify the shared outliers among them. But first, let's define some names.

```{r define_fig5_names}
dd.plot.name<-as.character("separate_delta-divergence.png")
dd.name<-as.character("sep.deltadivergence.txt")
sdd.name<-as.character("sep.smoothedDD.out.txt")
afs.plot.name<-as.character("p4.All_AFS.png")
stacks.sig.out<-"p4.stacks.sig.snps.txt"
annotations.name<-"p4.StacksFWSWOutliers_annotatedByGenome.csv"
```
```{r StacksFsts}
```
```{r compare2ScovelliGenome}
```
```{r read_compare}
fw.sig.reg<-read.csv(annotations.name)
```

There are `r nrow(stacks.sig)` shared SNPs using the Fisher's P as a cutoff.

The bayes factors and Fsts are all in the following chunk.

```{r Fig5Files}
```

Figure 5 includes Fst data, Bayes Factors data, colors from Structure, and reciprocal monophyly data, plus smoothed Fst values (which I think I will leave out this round).

#### Neighbor-joining trees

I had originally calculated monophyletic trees using the regular vcf file with SNPs

```{r NJTrees}
```
```{r recalc_trees, eval=FALSE}
ftrees.snp<-calc.ftrees(vcf,mono.tips = c("TXFW","ALFW","LAFW","FLLG"),
                        other.tips = pop.list[!pop.list %in% c("TXFW","ALFW","LAFW","FLLG")],out.file="p4.snp.ftrees.txt")


hap.vcf<-parse.vcf("stacks/batch_2.haplotypes.vcf")
hap.vcf$SNP<-paste(hap.vcf$`#CHROM`,hap.vcf$POS,sep=".")
ftrees.hap<-calc.ftrees(hap.vcf,mono.tips = c("TXFW","ALFW","LAFW","FLLG"),
                        other.tips = pop.list[!pop.list %in% c("TXFW","ALFW","LAFW","FLLG")],out.file="p4.hap.ftrees.txt")

```
```{r read_trees, echo=FALSE}
ftrees.snp<-read.delim("p4.snp.ftrees.txt", sep=' ')
ftrees.hap<-read.delim("p4.hap.ftrees.txt", sep=' ')
```
```{r id_monophyletic}
ftsnp.mono<-ftrees.snp[ftrees.snp$FWMonophyletic == TRUE & !is.na(ftrees.snp$FWMonophyletic),]
fthap.mono<-ftrees.hap[ftrees.hap$FWMonophyletic == TRUE & !is.na(ftrees.hap$FWMonophyletic),]
```


Compare the two:

```{r compare_NJ}
njcomp.table<-data.frame(SNP=c(nrow(ftrees.snp),nrow(ftrees.snp[is.na(ftrees.snp$FWMonophyletic),]),
                             nrow(ftsnp.mono)),
                       Haplotype=c(nrow(ftrees.hap),nrow(ftrees.hap[is.na(ftrees.hap$FWMonophyletic),]),
                             nrow(fthap.mono)))
rownames(njcomp.table)<-c("Number of Loci","Number w/ Missing Data", "Number with Monophyletic FW")
kable(njcomp.table, format = "markdown")
```

The ones with missing data are those that had data missing from at least one population for that locus, and these were excluded.

```{r get_hapvcf, echo=FALSE}
if(!("hap.vcf" %in% ls())){
  hap.vcf<-parse.vcf("stacks/batch_2.haplotypes.vcf")
  hap.vcf$SNP<-paste(hap.vcf$`#CHROM`,hap.vcf$POS,sep=".")
}
```
```{r compare_loci_NJ}
hap.mono.ids<-hap.vcf[hap.vcf$SNP %in% fthap.mono$SNP,c("SNP","ID")]
snp.mono.ids<-vcf[vcf$SNP %in% ftsnp.mono$SNP,c("SNP","ID")]
```

They share `r nrow(hap.mono.ids[hap.mono.ids$ID %in% snp.mono.ids$ID,])` RAD loci. I'll move forward with the haplotype analyses, since those are probably more informative.

Let's compare the genome-wide locations
```{r plottingFunctions, echo=FALSE}
```
```{r Fig5dataSetup}
```
```{r prepNJ_plotting, fig.keep='last'}
ftsnp<-assign.plotpos(ftsnp.mono,plot.scaffs,bounds,df.bp="Pos")
fthap<-assign.plotpos(fthap.mono,plot.scaffs,bounds,df.bp="Pos")

par(mfrow=c(2,1), oma=c(1,1,1,1),mar=c(1,1,1,1))
fwswt.fst<-fst.plot(fwsw.tx,fst.name = "Corrected.AMOVA.Fst", bp.name = "BP",chrom.name = "Chr", 
                    scaffs.to.plot=plot.scaffs, y.lim = c(0,1),scaffold.widths = bounds,pch=19,
                    pt.cols = c(grp.colors[1],grp.colors[2]),pt.cex=1,axis.size = 0,type='n')
abline(v=ftsnp$plot.pos) 
mtext("SNP-based \nFW monophyletic trees",2)
lgbreaks<-tapply(fwswt.fst$plot.pos,fwswt.fst$Chr,min)
lgbreaks<-c(lgbreaks[lgs],lgbreaks[23])
axis(1,lgbreaks,labels = FALSE)
meds<-NULL
for(i in 1:22){
  meds[i]<-lgbreaks[i]+((lgbreaks[i+1]-lgbreaks[i])/2)
}
names(lglab)<-plot.scaffs
axis(1,at=meds,labels = lgs,cex.axis=0.5,tck=0,las=2,hadj=0.5)

plot(c(min(fwswt.fst$plot.pos),max(fwswt.fst$plot.pos)),c(0,1),bty='n',type = 'n',axes=FALSE,xlab="",ylab="")
abline(v=fthap$plot.pos) 
mtext("haplotype-based \nFW monophyletic trees",2)
axis(1,lgbreaks,labels = FALSE)
axis(1,at=meds,labels = lgs,cex.axis=0.5,tck=0,las=2,hadj=0.5)
```

I don't really trust the haplotype calculations, actually. Let me see about using BEAST with the fasta output...
`populations -b 2 -W fwsw_results/subset.whitelist.txt -P fwsw_results/stacks -M fwsw_pops_map.txt --fasta`
#### Plot Fig. 5


Now I'm ready to plot Figure 5.
```{r plottingFunctions}
```

**still need to re-annotate the genome and do the swsw comparison plots. 
**might be nice to include other aspects in this graph, esp the sw-associated SNPs.
```{r}
ftmono<-fthap.mono
fig5.name<-"p4_stacks_fsts_njhap_fwsw_bf.png"
png(fig5.name,height=6,width=8,units="in",res=300)
addLines<-FALSE
addSmooth<-TRUE
```

```{r Fig5dataSetup}
```
```{r Fig5plot}
```

![Figure 5. Fsts](fwsw_results/p4_stacks_fsts_njhap_fwsw_bf.png)

## Figure 6

In Figure 6, we show different measures of diversity: pi (nucleotide diversity), heterozygosity, Jost's D, and delta-divergence. Additionally, we include the shared Fst outliers and putative loci, and highlight regions with high `pi` and \italic(H).

### Allele Frequency Spectrum
```{r calcAFS,eval=FALSE}
```
```{r plotAFS, echo=FALSE, eval=FALSE}
```

![Figure S1. Fsts](fwsw_results/p4.All_AFS.png)

### Pi
```{r pi_setup}
pi.file.name<-"p4.pi.txt"
avgpi.file.name<-"p4.avgpi.txt"
```
```{r pi, fig.keep='none'}
```
```{r pi_readin}
all.pi<-read.table(pi.file.name,header=T)
avg.pi.adj<-read.table(avgpi.file.name,header=T)
```

### Heterozygosity
```{r het_names}
all.het.name<-"p4.avg.het.txt"
avg.het.adj.name<-"p4.avg.het.adj.txt"
```
```{r het}
```
```{r read_het}
avg.het.adj<-read.delim(avg.het.adj.name,header=TRUE)
all.het<-read.delim(all.het.name,header=TRUE)
```

### delta-divergence
```{r setupDeltaD,eval=FALSE}
```
```{r readDeltaD, echo=FALSE}
dd.plot.name<-as.character("separate_delta-divergence.png")
dd.name<-as.character("sep.deltadivergence.txt")
sdd.name<-as.character("sep.smoothedDD.out.txt")
deltad<-read.delim(dd.name, header=TRUE)
```
```{r PlotDeltaD}
```
This plotting function also generates the smoothed \delta -divergence values.

### Jost's D

First, I must calculate Jost's D on each locus in the p4 dataset
```{r JostD, eval=FALSE}
sub.genind<-read.structure("stacks/subset.structure.stru",n.ind=698,
                           n.loc=9638,col.lab=1,col.pop=2,sep='\t',
                           row.marknames = 2,onerowperind=FALSE,ask=FALSE)
sub.genind@pop<-factor(gsub("sample_(\\w{4}).*","\\1",rownames(sub.genind@tab)))
jostd<-D_Jost(sub.genind) 
write.table(jostd$per.locus,"p4.jostd.perlocus.txt",sep='\t',col.names=FALSE,row.names = TRUE,quote=F)
```
Now this is done, so I don't need to evaluate it again -- I'll just need to read it in from a file when I want to use it.
```{r getJostsD, echo=FALSE}
jostd.name<-"p4.jostd.perlocus.txt"
```
```{r readJostD}
```

### Smooth the statistics
```{r smooth_name}
smoothed.name<-"p4_deltad_pi_het.png"
```
```{r smoothStats}
```
![Figure x. Smoothed variables](fwsw_results/p4_deltad_pi_het.png)


### Find the ones with high \pi and low \delta-divergence

```{r HighPIlowDD}
```

There are loci with high \pi and low \delta-divergence on `r length(unique(shared.upp$Chr))` chromosomes. 


```{r hPi_setup}
#also marine-fw fsts
fwsw<-read.delim("stacks/fw-sw_populations/batch_2.fst_marine-freshwater.tsv")
#and putative genes
put.genes<-read.delim("putative_genes.txt",header=TRUE,sep='\t')
#genome annotations
put.reg<-read.delim("putative.gene.regions.tsv",header=T)
#select genes of interest
fav.genes<-c("AQP3","TNS1","CAMKK1","mucin","CAII","NAKATPase","ARHGEF3")
genes2plot<-put.reg[put.reg$Gene %in% fav.genes,]
#shared Fst outliers
fw.sig.reg<-read.csv("p4.StacksFWSWOutliers_annotatedByGenome.csv")
h.pi.name<-"HandPi_subgenes.png"
row.settings<-c(4,4)
```
```{r plotHandPi}
```
![Figure 6. Low \delta-divergence and high \pi](fwsw_results/HandPi_subgenes.png)

## Figure 7

Figure 7 shows some example putative genes with smoothed Fsts, delta-divergence, shared Fst outliers, reciprocal monophyly, and saltwater-associated SNPs from Bayenv. This analysis is in another notebook.

