---
title: "FWSW with smallest dataset"
output: html_document
author: "Sarah P. Flanagan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
description: "Re-running the freshwater-saltwater analysis using only the dataset from pairwise population comparisons"
---

In my initial analysis of the freshwater-saltwater dataset, I had three vcf files: 
1. one generated from all pairwise comparisons of populations, containing SNPs only found in all 16 populations, in 75% of individuals, and with a minor allele frequency of at least 5%. ("separate")
2. one generated from all pairwise comparisons of populations, containing SNPs found in 4 populations, in 75% of individuals, and with a minor allele frequency of at least 5%. ("P4")
3. one generated from comparing lumped 'freshwater' and 'saltwater' populations, containing SNPs found in 50% of individuals and with a minor allele frequency of at least 5%. ("lumped")

I did the majority of the analyses using set #3, but would like to explore what changes if I use dataset #2. I think #1 is too restrictive. Dataset #2 is in the "subset" dataset, and is what I ran the structure analyses on. This is the dataset I'm going to move forward with for the paper.

Note that in most of these cases the actual analysis will be set to `eval=FALSE` once I've run it once, because then I save the output and only have to read it in, saving compilation time.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir='./fwsw_results/')
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../scripts/treemix_plotting_funcs.R")#I've modified these functions
library(knitr)
```

```{r access_analysis, echo=FALSE}
knitr::read_chunk("../scripts/fwsw_analysis.R")
```

```{r FWSWsetup, include=FALSE}
```

```{r pwiseFstsFiles,eval=FALSE}
```

```{r P4plink,cache=TRUE}
```

This P4/subset dataset has `r nrow(map.sub)` SNPs from `r length(unique(gsub("(\\d+)_\\d+","\\1",map.sub$V2)))` RAD loci, from `r nrow(ped.sub)` indivudals in 16 populations.

## Generate a new vcf file

The first thing to do is to create a vcf file using the subset parameters. I've already got a whitelist of loci in the subsetted dataset, so I need to run `populations -b 2 -W fwsw_results/subset.whitelist.txt -P fwsw_results/stacks -M fwsw_pops_map.txt --vcf`, which I did on 2017-12-18 on silivren-lond. I then re-named it to p4.vcf (and the other output files).


```{r read_vcf,cache=TRUE}
vcf<-parse.vcf("stacks/p4.vcf") #this is the smaller dataset
```
```{r vcfSetup, echo=TRUE}
```

The vcf file contains `r nrow(vcf)` SNPs from `r length(unique(vcf$ID))` RAD loci.

Choose a subset of the SNPs to re-use. [Do I need to do this?]

```{r choose_subset, eval=FALSE} 
chosen.snps<-choose.one.snp(vcf)$SNP
write.table(chosen.snps,"chosen.all.snps.txt",quote=F)
```

```{r read_subset}
chosen.snps<-unlist(read.table("chosen.all.snps.txt"))
```

There are `r length(chosen.snps)` SNPs that I'll use from the vcf file, from `r nrow(vcf)` RAD loci.

## Figure 1

The first figure in the paper is a map of the collection sites.

```{r map, eval=FALSE}
```
![Figure 1. Map of collection sites](fwsw_results/all_sites_map.jpg)

## Figure 2

The second figure in the paper is showing population structure, using STRUCTURE, adegenet, and PCAdapt. These analyses were run as exactly written in `fwsw_analysis.R`, so I won't reproduce that code here.

```{r Adegenet, eval=FALSE, echo=FALSE}
```
```{r pcadapt, eval=FALSE, echo=FALSE}
```
```{r readStructure, eval=FALSE, echo=FALSE}
```
```{r AnalyzeStructure, eval=FALSE, echo=FALSE}
```
```{r PopStructurePlot, eval=FALSE, echo=FALSE}
```

![Figure 2. Population Structure](fwsw_results/pop_structure_comb.jpeg)


## Figure 3

I don't need to re-calculate pairwise Jost's D, and Fsts using the P4 (or "subset") dataset, so I can just read in those files. But I do need to run Treemix and PopTree2.

### Treemix

To run treemix, I follow the following steps:

1. Fit tree without migration
2. Add migration edges using `-m`.
3. Use f3 and f4 ancestry estimation to approximate the amount of admixture and compare to treemix.
4. Use f4 statistics to understand poor fits.

All of these require setting a root, which is FLPB based on previous trees.

First, I need to create a file in the correct format, which uses the vcf file: 

```{r nameTreemix}
treemix.name<-"treemix/p4_treemix"
treemix.prefix<-"treemix/p4_"
poporder.file<-"treemix/poporder"
fst.tree.name<-as.character("ALLfst_cov_heatmap.png")
```
```{r generateTreemix, eval=FALSE}
```

Then, in unix, I need to run `gzip -c treemix/p4_treemix > treemix/p4_treemix.gz`. Now I can run `scripts/run_treemix.sh`, which implements steps 1 and 2, and which I need to run in Ubuntu. *Note that there are a lot of "no counts" warnings from treemix. Also, that it runs very quickly*

After that, I can evaluate the different outcomes.

```{r TreemixSetup}
```
```{r FLPBoutgroup, results="hide",fig.keep="high"}
```

Population pairs that are 'too far apart' on the tree (have high error estimates) are ones that are likely candidates for gene flow - and these are the squares with dark greens, blues, and black. These are LAFW-TXFW and ALFW-TXFW in almost all of the SE graphs

```{r FLPBmigration, results="hide",fig.keep="high"}
```

Look at the p-values: do migration events always improve the fit of the data?

```{r FLPBpvals}
```

All of the added migration edges improve the fit. Evaluating both the residual and migration edge plots, we can see that four migration edges reduces the error between LAFW & TXFW and ALFW & TXFW. The largest SE is between FLFW (FLLG) and itself, and secondarily between LAFW and itself. This means that those branches are surprisingly long, which I am comfortable accepting. The strongest migration edge, between the branch from the Atlantic Florida to Gulf Florida populations -> FLAB, is unsurprising because that is an intermediate location between the Atlantic and Gulf coasts. In some of the structure analyses it clusters with the Gulf coast and in others it is its own admixed group - supporting the tree structure here.

The other migration events are somewhat more surprising. We will evaluate those using the three and four population analyses.

#### Evaluating migration edges

First, let's read in the three and four population analysis results. These tested all possible three- and four-population tree groups to see whether they pass a test of 'treeness'. If not, their p-value will be small, and they don't form a nice tree.

```{r f3f4}
f3.name<-"treemix/p4_threepop.txt"
f4.name<-"treemix/p4_fourpop.txt"

#extract the relevant lines
extract.fs<-function(filename,pat="^[A-Z]{4};"){
  f<-readLines(filename)
  fmatch<-f[grep(pat,f)]
  f<-read.table(text=fmatch)
  colnames(f)<-c("pops","f","SE","Z")
  return(f)
}
f3<-extract.fs(f3.name)
f4<-extract.fs(f4.name,pat="^[A-Z]{4},")

#add p-values
f3$p<-pnorm(f3$Z)
f4$p<-pnorm(f4$Z)

```

Now we can investigate the migration edges added to the trees. 

##### Atlantic/Gulf->FLAB

This least surprising migration edge would be expected to show a signature of admixture. I'll check the treeness of FLHB;FLSI,FLAB and FLHB,FLCC;FLSI,FLAB. For comparison, I can look at FLHB;FLSI,FLFD and FLHB,FLCC;FLSI,FLFD

```{r FL}
checks3<-c("FLHB;FLSI,FLAB","FLHB;FLFD,FLSI")
f3[f3$pops %in% checks3,]
checks4<-c("FLSI,FLAB;FLHB,FLCC","FLFD,FLSI;FLHB,FLCC")
f4[f4$pops %in% checks4,]
```
They pass the three-population tests but not the four-population tests. 

##### TXFW->TXCB

To investigate this migration edge, I need to evaluate whether a [TXFW[TXCB,TXCC]] or [TXFW[TXCB,TXSP]] topology is an appropriate tree. 

```{r TX_f3}
checks<-c("TXFW;TXCC,TXCB",
          "TXFW;TXSP,TXCB")
f3[f3$pops %in% checks,]
```

Neither of these fail the treeness test, so TXFW is essentially functioning as an effective outgroup/more ancestral population. Let's check if a four population tree also makes sense.

```{r TX_f4}
f4[f4$pops %in% "TXSP,TXCC;TXFW,TXCB",]
```

This also passes the treeness test - so this isn't an actual admixture event, more of demonstrating shared ancestry.

##### TXFW->LAFW/ALFW

This migration edge would suggest a three-population structure of [TXFW[ALFW,LAFW]] or a four-population structure of [TXFW,TXCB[LAFW,ALFW]] or [TXFW,ALST[LAFW,ALFW]]
```{r TXFW_ALLAFW}

checks<-c("TXFW,TXCB;LAFW,ALFW",
          "TXFW,ALST;LAFW,ALFW")#to get the correct order of populations I had to
                                #use grep and manually try a few different ones
f4[f4$pops %in% checks,]
f3[f3$pops == "TXFW;LAFW,ALFW",]

```

The three-population test does not fail the treeness test but the four-population tests do fail the treeness tests. This suggests that TXFW functions as an outgroup to the LAFW and ALFW - they are perhaps derived from the TXFW population rather than experiencing current admixture.

##### FLFW->TX/AL

FLLG is actually FLFW, and there's a migration edge from it to the Alabama/Louisiana clade and the Texas clade. So, we can test FLLG;ALST,TXFW, FLLG;ALFW,TXCB, FLLG;ALFW,TXFW or FLLG;ALST,TXCC - see if the migration is specifically to freshwater populations or not.

```{r FLFW_f3}
checks<-c("FLLG;TXFW,ALST","FLLG;TXCB,ALFW","FLLG;TXCB,LAFW",#mix of freshwater
          "FLLG;TXFW,ALFW","FLLG;TXFW,LAFW",                 #all freshwater
          "FLLG;TXCC,ALST")                                  #no freshwater
f3[f3$pops %in% checks,]
```
These all pass the treeness test.

#### Plot the chosen tree

```{r treemix_define}
treemix.file<-as.character("treemix/p4_k100bFLPBr.cov.gz")
tm.vertices<-"treemix/p4_k100bFLPBrm4.vertices.gz"
tm.plot<-"treemix/p4_treemix_m4_FLPB.png"
tm.tree<-"treemix/p4_k100bFLPBrm4"
```
```{r TreemixFavorite, echo=FALSE,results="hide",fig.keep="high"}
```

### PopTree2

For the PopTree2 analysis, I need to convert the vcf file to genepop format. I did this using PGDSpider2. Then I ran PopTree2 on Windows10, using Da to calculate neighbor-joining trees and using 1000 bootstrap replicates.

Or, if that doesn't work,
```{r RemoveMissingData}
```
```{r poptree_names}
gpop.name<-"poptree/p4.genepop"
sub.prefix<-"poptree/p4_"
vcf<-remove.missing.data(vcf, pop.list)
```
```{r CreatePoptreeSubsets, eval=FALSE}
```


And then run poptree. Poptree ran on the full dataset as well as the subsets of 1000 SNPs. Did they all provide similar results? What does the consensus tree look like?

```{r poptree_prefix, eval=FALSE}
poptree.dir<-"poptree/"
poptree.prefix<-"p4"
poptree.png<-"p4.poptree.png"
```
```{r AnalyzePoptree, eval=FALSE}
```
![All Trees](fwsw_results/poptree/p4.png)

Based on this, I'm going to move forward just with the full dataset (which includes bootstrap values).

```{r poptree_prelimplot,eval=FALSE,echo=FALSE}
#do this to test which branches are which using the colors below
plot.phylo(pt.subtree)
```
```{r poptree_definecols,eval=FALSE}
clcolr <- rep("black", dim(pt.subtree$edge)[1])
clcolr[c(6,19,20,21,22)]<-all.colors[3]
```
```{r PlotFullPoptreeSubset, eval=FALSE}
```
![PopTree](fwsw_results/p4.poptree.png)

### Make Fig 3.

To get the Poptree distance matrix, I copied and pasted the distance matrix in the `p4.out` file into a new file and saved it as `p4.distance.out`. I had to first save each part of the matrix as text files, open them in Excel to standardize the spacings, merge them, and then save them.

```{r fig3_setup}
pt.dist<-as.matrix(read.table("poptree/p4.distance.out",header=T,row.names=1,sep='\t'))
jostpw<-as.matrix(read.table("Subset.JostsD.tsv",header=T,sep='\t'))
pwise.fst.raw<-read.table("stacks/p4_fst_summary.txt",header=T,row.names=1,sep='\t')
pwise.fst<-matrix(nrow=length(pop.list),ncol=length(pop.list))
dimnames(pwise.fst)[[1]]<-dimnames(pwise.fst)[[2]]<-pop.list
for(pop1 in 1:length(pop.list)){
  for(pop2 in 1:length(pop.list)){
    if(pop1 != pop2){
      raws<-c(pwise.fst.raw[pop.list[pop1],pop.list[pop2]],pwise.fst.raw[pop.list[pop2],pop.list[pop1]])
      pwise.fst[pop.list[pop1],pop.list[pop2]]<-raws[!is.na(raws)]
    }
  }
}
dimnames(pwise.fst)[[1]]<-dimnames(pwise.fst)[[2]]<-pop.labs
pwise.fst[lower.tri(pwise.fst)]<-NA
heatmaps.name<-"p4.heatmap.png"
```
```{r HeatmapCols}
```
```{r treemix}
```
```{r Fig3Setup}
```
```{r PlotHeatmaps}
```

## Figure 4

Figure 4 is the Poptree2 and Treemix trees next to each other

```{r tree_files,eval=FALSE}
plotName<-"p4.trees.png"
tm.tree<-"treemix/p4_k100bFLPBrm4"
pt.subtree<-read.tree("poptree/p4.nwk")
rect.start<-0.1
clcolr <- rep("grey27", dim(pt.subtree$edge)[1])
clcolr[c(6,19,20,21,22)]<-all.colors[3]
```
```{r plotTreemixPoptree,eval=FALSE}
```
![Figure 4. Trees](fwsw_results/p4.trees.png)

## Figure 5

I need to re-run `populations` because I don't seem to have the correct fst files. I can use the whitelist and hopefully include bootstrapping and kernel smoothing: 

`populations -b 2 -W fwsw_results/subset.whitelist.txt -P fwsw_results/stacks -M fwsw_pops_map.txt --fstats --vcf_haplotypes --genomic --bootstrap -k `

And then I will identify the shared outliers among them. But first, let's define some names.

```{r reset_vcf}
vcf<-parse.vcf("stacks/p4.vcf")
```
```{r vcfSetup, echo=TRUE}
```

```{r define_fig5_names}
dd.plot.name<-as.character("separate_delta-divergence.png")
dd.name<-as.character("sep.deltadivergence.txt")
sdd.name<-as.character("sep.smoothedDD.out.txt")
afs.plot.name<-as.character("p4.All_AFS.png")
stacks.sig.out<-"p4.stacks.sig.snps.txt"
annotations.name<-"p4.StacksFWSWOutliers_annotatedByGenome.csv"
```
```{r StacksFsts}
```
```{r compare2ScovelliGenome,eval=FALSE}
```
```{r read_compare}
fw.sig.reg<-read.csv(annotations.name)
```

There are `r nrow(stacks.sig)` shared SNPs using the Fisher's P as a cutoff.

The bayes factors and Fsts are all in the following chunk.

```{r Fig5Files}
```

Figure 5 includes Fst data, Bayes Factors data, colors from Structure, and reciprocal monophyly data, plus smoothed Fst values (which I think I will leave out this round).


#### Plot Fig. 5


Now I'm ready to plot Figure 5.

```{r}
fig5.name<-"p4_stacks_fsts_fwsw_bf.png"
addLines<-FALSE
addSmooth<-TRUE
```
```{r plottingFunctions,echo=FALSE}
```
```{r Fig5dataSetup}
```
```{r FstBayenvPlot}
```

![Figure 5. Fsts](fwsw_results/p4_stacks_fsts_fwsw_bf.png)

There seems to be an overabundance of shared outliers on LG8. I can test this using the multinomial distribution. 
```{r overrep_chrom}
sig.chrom<-stacks.sig[stacks.sig$Chr %in% lgs,]
sig.chrom$Chr<-factor(sig.chrom$Chr)
nloci<-nrow(sig.chrom)
nchrom<-length(lgs)
exp.perchrom<-rep(nloci/length(lgs),length(lgs))
names(exp.perchrom)<-lgs
exp.perchrom
obs.perchrom<-tapply(sig.chrom$Locus.ID,sig.chrom$Chr,length)[lgs]
names(obs.perchrom)<-lgs
obs.perchrom[is.na(obs.perchrom)]<-0
obs.perchrom
dmultinom(x = obs.perchrom,prob = exp.perchrom)
```


I can also look for overlapping loci in pairwise saltwater-saltwater comparisons.

```{r swsw_name}
swsw.name<-"p4_stacks_swsw.png"
```
```{r SWSWneighbors}
```
![SWSW Fsts](fwsw_results/p4_stacks_swsw.png)

## Figure 6

In Figure 6, we show different measures of diversity: pi (nucleotide diversity), heterozygosity, Jost's D, and delta-divergence. Additionally, we include the shared Fst outliers and putative loci, and highlight regions with high `pi` and \italic(H).

### Allele Frequency Spectrum
```{r calcAFS,eval=FALSE}
```
```{r plotAFS, echo=FALSE, eval=FALSE}
```

![Figure S1. Fsts](fwsw_results/p4.All_AFS.png)

### Pi
```{r pi_setup}
pi.file.name<-"p4.pi.txt"
avgpi.file.name<-"p4.avgpi.txt"
```
```{r pi, fig.keep='none',eval=FALSE}
```
```{r pi_readin}
all.pi<-read.table(pi.file.name,header=T)
avg.pi.adj<-read.table(avgpi.file.name,header=T)
```

### Heterozygosity
```{r het_names}
all.het.name<-"p4.avg.het.txt"
avg.het.adj.name<-"p4.avg.het.adj.txt"
```
```{r het,eval=FALSE}
```
```{r read_het}
avg.het.adj<-read.delim(avg.het.adj.name,header=TRUE)
all.het<-read.delim(all.het.name,header=TRUE)
```



### delta-divergence
```{r setupDeltaD,eval=FALSE}
```
```{r readDeltaD, echo=FALSE}
dd.plot.name<-as.character("separate_delta-divergence.png")
dd.name<-as.character("sep.deltadivergence.txt")
sdd.name<-as.character("sep.smoothedDD.out.txt")
deltad<-read.delim(dd.name, header=TRUE)
```
```{r PlotDeltaD}
```
This plotting function also generates the smoothed \delta -divergence values.

### Jost's D

First, I must calculate Jost's D on each locus in the p4 dataset
```{r JostD, eval=FALSE}
sub.genind<-read.structure("stacks/subset.structure.stru",n.ind=698,
                           n.loc=9638,col.lab=1,col.pop=2,sep='\t',
                           row.marknames = 2,onerowperind=FALSE,ask=FALSE)
sub.genind@pop<-factor(gsub("sample_(\\w{4}).*","\\1",rownames(sub.genind@tab)))
jostd<-D_Jost(sub.genind) 
write.table(jostd$per.locus,"p4.jostd.perlocus.txt",sep='\t',col.names=FALSE,row.names = TRUE,quote=F)
```
Now this is done, so I don't need to evaluate it again -- I'll just need to read it in from a file when I want to use it.
```{r getJostsD, echo=FALSE}
jostd.name<-"p4.jostd.perlocus.txt"
```
```{r readJostD}
```

### Smooth the statistics
```{r smooth_name}
smoothed.name<-"p4_deltad_pi_het.png"
```
```{r smoothStats}
```
![Figure x. Smoothed variables](fwsw_results/p4_deltad_pi_het.png)


### Find the ones with high $\pi$ and low $\delta$-divergence

```{r HighPIlowDD}
```

There are loci with high $\pi$ and low $\delta$-divergence on `r length(unique(shared.upp$Chr))` chromosomes. 

Instead of the lumped marine-freshwater $F_{ST}$ values that I used originally, I'm gonna plot the average of pairwise $F_{ST}$ values.

```{r avg_fsts}
fst.means<-fwsw.al
for(i in 1:nrow(fst.means)){
  if(fst.means$Locus.ID[i] %in% fwsw.fl$Locus.ID &
     fst.means$Locus.ID[i] %in% fwsw.la$Locus.ID &
     fst.means$Locus.ID[i] %in% fwsw.tx$Locus.ID){
      mu<-mean(fwsw.fl$Corrected.AMOVA.Fst[fwsw.fl$Locus.ID==fst.means$Locus.ID[i]],
               fwsw.la$Corrected.AMOVA.Fst[fwsw.la$Locus.ID==fst.means$Locus.ID[i]],
               fwsw.al$Corrected.AMOVA.Fst[fwsw.al$Locus.ID==fst.means$Locus.ID[i]],
               fwsw.tx$Corrected.AMOVA.Fst[fwsw.tx$Locus.ID==fst.means$Locus.ID[i]])
      fst.means$Corrected.AMOVA.Fst[i]<-mu
  }
  else{
    fst.means$Corrected.AMOVA.Fst[i]<-NA
  }
}
fst.means<-fst.means[!is.na(fst.means$Corrected.AMOVA.Fst),]
fwsw<-fst.means
```


```{r hPi_setup}
fst.points<-FALSE
#and putative genes
put.genes<-read.delim("putative_genes.txt",header=TRUE,sep='\t')
#genome annotations
put.reg<-read.delim("putative.gene.regions.tsv",header=T)
#select genes of interest
#fav.genes<-c("AQP3","TNS1","CAMKK1","mucin","CAII","NAKATPase","ARHGEF3")
fav.genes<-c("TNS1","CAII","TRIM14","VATPase")
genes2plot<-put.reg[put.reg$Gene %in% fav.genes,]
#shared Fst outliers
fw.sig.reg<-read.csv("p4.StacksFWSWOutliers_annotatedByGenome.csv")
h.pi.name<-"HandPi_subgenes.png"
row.settings<-c(4,3)
chroms2plot<-unique(shared.upp$Chr)
chroms2plot<-chroms2plot[chroms2plot != "LG19"]
```
```{r plotHandPi}
```
![Figure 6. Low \delta-divergence and high \pi](fwsw_results/HandPi_subgenes.png)


### Look for regions of reduced diversity as evidence of selective sweeps.

```{r low_diversity}
upp.pi<-NULL
low.pi<-NULL
upp.het<-NULL
low.het<-NULL
upp.dd<-NULL
low.dd<-NULL
for(i in 1:length(lgs)){
  upp.pi<-rbind(upp.pi,avg.pi.adj[avg.pi.adj$Avg.Stat >= 
                     quantile(avg.pi.adj$Avg.Stat[avg.pi.adj$Chr %in% lgs[i]],0.95) &
                     avg.pi.adj$Chr %in% lgs[i],])
  low.pi<-rbind(low.pi,avg.pi.adj[avg.pi.adj$Avg.Stat <= 
                     quantile(avg.pi.adj$Avg.Stat[avg.pi.adj$Chr %in% lgs[i]],0.05) &
                     avg.pi.adj$Chr %in% lgs[i],])

  upp.het<-rbind(upp.het,avg.het.adj[avg.het.adj$Avg.Stat >= 
                       quantile(avg.het.adj$Avg.Stat[avg.het.adj$Chr %in% lgs[i]],0.95) &
                       avg.het.adj$Chr %in% lgs[i],])
  low.het<-rbind(low.het,avg.het.adj[avg.het.adj$Avg.Stat <= 
                       quantile(avg.het.adj$Avg.Stat[avg.het.adj$Chr %in% lgs[i]],0.05) &
                       avg.het.adj$Chr %in% lgs[i],])

  
}
shared.low<-low.pi[low.pi$plot.pos %in% low.het$plot.pos,]
shared.low$plot.min<-shared.low$Avg.Pos-250000
shared.low$plot.max<-shared.low$Avg.Pos+250000

h.pi.name<-"lowdiv_subgenes.png"
row.settings<-c(4,3)
chroms2plot<-unique(shared.low$Chr)
shared.upp<-shared.low
fst.points<-FALSE
```
```{r plotHandPi}
```

![Low pi and low het](fwsw_results/lowdiv_subgenes.png)


#### Test for selective sweeps

To look for selective sweeps, I'm going to use the FLK R code by Bonhomme et al, downloaded from https://qgsp.jouy.inra.fr/index.php?option=com_content&view=article&id=50&Itemid=55

The mandatory input is a matrix of allele frequencies for each population.

```{r FLK_freqs,eval=FALSE}
calc.allFreqs<-function(vcf,pop.list, pop.labs){
  allFreqs<-do.call(rbind,lapply(pop.list, function(pop){
    this.vcf<-cbind(vcf[,1:9],vcf$SNP,vcf[,grep(pop,colnames(vcf))])
    afs<-do.call(rbind,apply(this.vcf,1,calc.afs.vcf))
    return(afs$RefFreq)
  }))
  colnames(allFreqs)<-vcf$SNP
  rownames(allFreqs)<-pop.labs
  return(allFreqs)
}

freqs<-calc.allFreqs(remove.missing.data(vcf, pop.list),pop.list,pop.labs)
write.table(freqs,"flk.freqs",row.names = TRUE)
```
```{r FLK}
source("../scripts/FLK.R")
library(ape); library(phangorn)
freqs<-read.table(freqs,row.names=1)
## estimate the population tree using Reynolds distances
## computed on the SNP data, without specifying an outgroup
Fsnp<-Fij(freqs)

## Now compute the FLK and LK tests
tests<-FLK(freqs,Fsnp) 

```

Then I run the `programs/FLKnull.py` program on the output to estimate the empirical null distribution. Once that has run, we use the following code provided by Bonhomme et al to plot the null distribution

```{r plotNull}
null<-read.table('envelope.txt',head=T)
plot(tests$Ht,tests$F.LK,pch=19,col="gray",xlab='Heterozygosity',ylab='FLK statistic',xlim=c(0,0.5))
lines(null$Ht,null$q0.005,type='l',col='navy')
lines(null$Ht,null$q0.995,type='l',col='navy')
lines(null$Ht,null$q0.025,type='l',col='navy')
lines(null$Ht,null$q0.975,type='l',col='navy')
lines(null$Ht,null$q0.5,type='l',col='navy')
lines(smooth.spline(null$Ht,null$q0.995))
lines(smooth.spline(null$Ht,null$q0.005))
lines(smooth.spline(null$Ht,null$q0.025),lty=2)
lines(smooth.spline(null$Ht,null$q0.975),lty=2)
lines(smooth.spline(null$Ht,null$q0.5),lty=3)
```

## Figure 7

Figure 7 shows some example putative genes with smoothed Fsts, delta-divergence, shared Fst outliers, reciprocal monophyly, and saltwater-associated SNPs from Bayenv. This analysis is in another notebook.


