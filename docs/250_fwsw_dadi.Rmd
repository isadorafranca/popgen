---
title: "FWSW analysis with dadi"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,out.extra='',fig.pos="H")
knitr::opts_knit$set(root.dir='./fwsw_results/')
```
```{r source}
source("../../gwscaR/R/gwscaR.R")
source("../../gwscaR/R/gwscaR_plot.R")
source("../../gwscaR/R/gwscaR_utility.R")
source("../../gwscaR/R/gwscaR_fsts.R")
source("../../gwscaR/R/gwscaR_popgen.R")
source("../../gwscaR/R/vcf2dadi.R")
library(knitr)
pop.list<-c("ALFW","ALST","FLCC","FLLG","LAFW","TXCC","TXFW")
```



# Create a dadi SNPs file from the vcf

```{r create_dadi}
dadi<-vcf2dadiSNPs(vcf,pop.list = pop.list,filename = "dadi_analysis/fwsw.dadi.snps")
dadi<-read.delim("dadi_analysis/fwsw.dadi.snps")
projections<-unlist(lapply(pop.list,function(pop){ n<-length(grep(pop,colnames(vcf)))}))*2

names(projections)<-pop.list
best.pops<-c("TXFW","TXCB","LAFW","ALST","ALFW","FLLG","FLCC","TXFW ","TXCB ","LAFW ","ALST ","ALFW ","FLLG ","FLCC ")
best.pops<-c("TXFW","TXCB","LAFW","ALST","ALFW","FLLG","FLCC","TXFW.1","TXCB.1","LAFW.1","ALST.1","ALFW.1","FLLG.1","FLCC.1")
dadi<-dadi[,c("Ingroup","Outgroup","Allele1",best.pops[1:7],"Allele2",best.pops[8:14],"GeneID","Position")]
dim(dadi[rowSums(dadi[,colnames(dadi) %in% best.pops])==sum(projections[best.pops[1:7]]),])

#transform this and remove everything but population info for ease of operations
dd<-as.data.frame(cbind(colnames(dadi)[colnames(dadi) %in% best.pops],t(dadi[,colnames(dadi) %in% best.pops])),row.names = 0,stringsAsFactors = FALSE)
#rename the pops to be factors, essentially
dd$V1<-gsub("\\.1","",dd$V1)
#calculate sums per locus for each population
ns<-data.frame(do.call(rbind,lapply(2:ncol(dd),function(c){ tapply(dd[,c],dd$V1,function(x){ sum(as.numeric(x)) }) })))
rownames(ns)<-dadi$GeneID
nozeros<-ns[!(apply(ns, 1, function(y) any(y == 0))),] #512 had zeroes
props<-apply(nozeros,2,function(x) { p<-x/max(x) } )
keepers<-props[apply(props, 1, function(y) any(y >=0.75)),]

#now save these in the dadi format
write.table(dadi[dadi$GeneID %in% rownames(keepers),],"dadi_analysis/fwsw.dadi.pruned.snps",quote=FALSE,row.names = FALSE,
            col.names = c("Ingroup","Outgroup","Allele1","TXFW","TXCB","LAFW","ALST","ALFW","FLLG","FLCC","Allele2","TXFW","TXCB","LAFW","ALST","ALFW","FLLG","FLCC","GeneID","Position"))
```

```{r check_dadis}
vcf.files<-c("stacks/populations_subset50/batch_2.vcf",
             "stacks/populations_subset75/batch_2.vcf",
             #"stacks/populations_subset85/batch_2.vcf",
             #"stacks/populations_subset90/batch_2.vcf",
             #"stacks/populations_subset95/batch_2.vcf",
             "stacks/populations_subset100/batch_2.vcf")

dadis<-lapply(vcf.files,function(file){
  full.vcf<-parse.vcf(file)
  vcf<-choose.one.snp(full.vcf)
  vcf.out.name<-gsub("batch_2.vcf","batch_2.pruned.vcf",file)
  write.table(x = vcf,file = vcf.out.name,quote = FALSE,sep='\t',row.names = FALSE,col.names = TRUE)
  dadi.out<-paste("dadi_analysis/fwsw",gsub(".*populations_subset(\\d+).*","\\1",file),".dadi.snps",sep="")
  pop.list<-c("ALFW","ALST","FLCC","FLLG","LAFW","TXCC","TXFW")
  dadi<-vcf2dadiSNPs(vcf,pop.list = pop.list,filename = dadi.out)
  return(dadi)
})

#compare
kable(cbind(file=vcf.files,numer_snps=unlist(lapply(dadis,nrow))))
```

I'm going to use th 75% of individuals dataset.

## Analyze 1D dadi results

I ran the optimize functions from (dportik's dadi pipeline)[https://github.com/dportik/dadi_pipeline] for each of the 7 populations. Now I need to see what the optimal parameters are (with maximum log likelihood).

```{r dadi.optimal}
dadi.optimal<-function(opt.file){
  model.opt<-read.delim(opt.file,sep='\t',header=TRUE)
  if(length(grep("Model",model.opt$Model))>0){  #THERE SHOULDN'T BE REPEATED HEADER ROWS
    model.opt<-model.opt[-which(model.opt$Model=="Model"),]
    warning('The model has been run multiple times and output has been concatenated') 
  }
  opt<-model.opt[which.max(as.numeric(as.character(model.opt$log.likelihood))),]
  opt$params<-gsub("\\.\\.",",",gsub("optimized_params.(.*)","\\1",colnames(opt)[7]))
  colnames(opt)[7]<-"optimized_params"
  return(opt)
}

```

```{r dadi.modelcomp}
dadi.modelcomp<-function(path,pattern,id){
  opt.files<-list.files(path = path,pattern = pattern,full.names = TRUE)
  #find the best parameter set for each model using maximum log likelihood
  opts<-do.call(rbind,lapply(opt.files,dadi.optimal))
  #rank them by AIC
  opts$rank<-rank(opts$AIC)
  opts$id<-id
  opts<-opts[order(opts$rank),]
}
```

```{r}
opt.params<-do.call(rbind,lapply(pop.list, function(pop,dadi.dir="dadi_analysis"){
  if(length(grep("/^",dadi.dir))==0){
    dadi.dir<-paste(dadi.dir,"/",sep="")
  }
  path<-paste(dadi.dir,pop,sep="")
  opts<-dadi.modelcomp(path=path,pattern="optimized")
  return(opts)
}))
write.table(opt.params,"dadi_analysis/1D_optimal_parameters.txt",sep='\t',quote=FALSE,col.names = TRUE,row.names = FALSE)
```
```{r}
opt.params<-read.delim("dadi_analysis/1D_optimal_parameters.txt",header = TRUE)
kable(opt.params)
```



## Analyze 2D FL optimization results


I ran the optimize functions from (dportik's dadi pipeline)[https://github.com/dportik/dadi_pipeline] for a set of 2D demographic models for the Florida populations (FLFW and FLCC):

* Split into two populations, no migration (distributed with `dadi-pipeline`)
* Split into two populations, with continuous symmetric migration (distributed with `dadi-pipeline`)
* Split into two populations, with continuous asymmetric migration (distributed with `dadi-pipeline`)
* Split into two pops, isolation with migration model (distributed with `dadi`)
* Split into two pops, growth in one pop and two epoch in another, no migration (custom model specified in `scripts/250_custom_dadi_models.py`)
* Split into two pops, growth in one pop and two epoch in another, symmetric migration (custom model specified in `scripts/250_custom_dadi_models.py`)
* Split into two pops, growth in one pop and two epoch in another, asymmetric migration (custom model specified in `scripts/250_custom_dadi_models.py`)

At least some of the runs in all of these do not work well (result in "WARNING:Numerics:Extrapolation may have failed. Check resulting frequency spectrum for unexpected results; WARNING:Inference:Model is masked in some entries where data is not"), but the output will tell me more about how frequently it occurs (by parameters showing up as 'nan' instead of values)

Now I need to see what the optimal parameters are for these 7 different runs so that I can run those models for additional iterations and/or compare model fits -- after which I will simulate data with `ms`.

```{r}
fl.opts<-dadi.modelcomp(path = "dadi_analysis",pattern="fl.*optimized.*",id="FL2D")
kable(fl.opts,caption = "'Best' runs of each of the models for the Florida populations 2D demographic inference")
```

This doesn't tell us about which models had trouble converging, though, so let's tally up the number of 'nan's in each file.

```{r dadi.nan}
dadi.nan<-function(opt.file){
  model.opt<-read.delim(opt.file,sep='\t',header=TRUE)
  if(length(grep("Model",model.opt$Model))>0){  #THERE SHOULDN'T BE REPEATED HEADER ROWS
    model.opt<-model.opt[-which(model.opt$Model=="Model"),]
    warning('The model has been run multiple times and output has been concatenated') 
  }
  nn<-nrow(model.opt[is.na(model.opt$AIC),])
  nr<-nrow(model.opt)
  return(data.frame(Model=unique(model.opt$Model),NumReps=nr,NumNan=nn))
}
  
```

```{r}
fl.nans<-do.call(rbind,lapply(list.files(path = "dadi_analysis",pattern="fl.*optimized.*",full.names = TRUE),dadi.nan))
```
